# name: production

# on:
#   workflow_dispatch:
#     inputs:
#       commit_sha:
#         description: "Commit SHA to promote to Production"
#         required: true
#         type: string
#       action:
#         description: "What to run"
#         required: true
#         type: choice
#         options:
#           - generate-sql
#           - promote

# permissions:
#   contents: read
#   packages: write
#   actions: read

# jobs:
#   generate_sql_production:
#     name: Generate SQL migration script (Production)
#     runs-on: self-hosted
#     if: github.ref == 'refs/heads/main' && inputs.action == 'generate-sql'
#     steps:
#       - name: Checkout selected commit
#         uses: actions/checkout@v4
#         with:
#           fetch-depth: 0
#           ref: ${{ inputs.commit_sha }}

#       - name: Create output directory
#         run: mkdir -p ./out

#       - name: Generate EF Core idempotent SQL script
#         run: |
#           dotnet ef migrations script \
#             --project src/backend/ForeverBloom.Persistence \
#             --idempotent \
#             --output ./out/migrations.sql \
#             --context ApplicationDbContext \
#             --configuration Release

#       - name: Upload SQL script artifact
#         uses: actions/upload-artifact@v4
#         with:
#           name: migrations-sql-prod-${{ inputs.commit_sha }}
#           path: ./out/migrations.sql

#   promote_production:
#     name: Tag and deploy to Production
#     runs-on: self-hosted
#     if: github.ref == 'refs/heads/main' && inputs.action == 'promote'
#     steps:
#       - name: Verify SQL script artifact for Production exists for commit
#         uses: actions/github-script@v7
#         env:
#           COMMIT_SHA: ${{ inputs.commit_sha }}
#         with:
#           script: |
#             const commit = process.env.COMMIT_SHA || (context.payload.inputs && context.payload.inputs.commit_sha) || '';
#             const { owner, repo } = context.repo;
#             const { data } = await github.rest.actions.listArtifactsForRepo({ owner, repo, per_page: 100 });
#             const name = `migrations-sql-prod-${commit}`;
#             const found = data.artifacts.find(a => a.name === name && !a.expired);
#             if (!found) {
#               core.setFailed(`Required SQL artifact not found: ${name}. Run with action=generate-sql first.`);
#             } else {
#               core.info(`Found SQL artifact: ${name} (id=${found.id}).`);
#             }

#       - name: Checkout repository (for compose files)
#         uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - name: Compute tags
#         id: tags
#         run: |
#           SHORT_SHA=$(echo "${{ inputs.commit_sha }}" | cut -c1-7)
#           OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
#           REGISTRY_PREFIX="ghcr.io/${OWNER_LC}"
#           echo "REGISTRY_PREFIX=${REGISTRY_PREFIX}" >> $GITHUB_OUTPUT
#           echo "TAG_COMMIT=commit-${SHORT_SHA}" >> $GITHUB_OUTPUT

#       - name: Log in to GHCR
#         env:
#           DOCKER_USER: ${{ github.repository_owner }}
#           DOCKER_PASSWORD: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}
#         run: echo "$DOCKER_PASSWORD" | docker login ghcr.io -u "$DOCKER_USER" --password-stdin

#       - name: Verify Staging images match commit
#         env:
#           REGISTRY_PREFIX: ${{ steps.tags.outputs.REGISTRY_PREFIX }}
#           TAG_COMMIT: ${{ steps.tags.outputs.TAG_COMMIT }}
#         run: |
#           set -euo pipefail
#           for IMG in backend frontend; do
#             echo "Checking ${IMG}"
#             docker pull ${REGISTRY_PREFIX}/foreverbloom-${IMG}:staging
#             docker pull ${REGISTRY_PREFIX}/foreverbloom-${IMG}:${TAG_COMMIT}
#             ID_STAGING=$(docker inspect --format='{{.Id}}' ${REGISTRY_PREFIX}/foreverbloom-${IMG}:staging)
#             ID_COMMIT=$(docker inspect --format='{{.Id}}' ${REGISTRY_PREFIX}/foreverbloom-${IMG}:${TAG_COMMIT})
#             if [ "$ID_STAGING" != "$ID_COMMIT" ]; then
#               echo "Mismatch for ${IMG}: staging does not match ${TAG_COMMIT}." >&2
#               exit 1
#             fi
#           done

#       - name: Retag images to :prod and push
#         env:
#           REGISTRY_PREFIX: ${{ steps.tags.outputs.REGISTRY_PREFIX }}
#           TAG_COMMIT: ${{ steps.tags.outputs.TAG_COMMIT }}
#         run: |
#           for IMG in backend frontend; do
#             docker tag ${REGISTRY_PREFIX}/foreverbloom-${IMG}:${TAG_COMMIT} ${REGISTRY_PREFIX}/foreverbloom-${IMG}:prod
#             docker push ${REGISTRY_PREFIX}/foreverbloom-${IMG}:prod
#           done

#       - name: Prepare production directory
#         env:
#           DEPLOY_DIRECTORY: ${{ secrets.PROD_DEPLOY_DIRECTORY }}
#           GITHUB_WORKSPACE: ${{ github.workspace }}
#         run: |
#           cp "${GITHUB_WORKSPACE}/deploy/docker-compose.prod.yml" "${DEPLOY_DIRECTORY}"

#       - name: Deploy to Production
#         env:
#           DEPLOY_DIRECTORY: ${{ secrets.PROD_DEPLOY_DIRECTORY }}
#         run: |
#           cd ${DEPLOY_DIRECTORY}
#           docker compose -f docker-compose.prod.yml pull
#           docker compose -f docker-compose.prod.yml up -d --force-recreate --remove-orphans
